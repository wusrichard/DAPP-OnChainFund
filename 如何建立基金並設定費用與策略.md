# 如何建立基金並設定費用與策略

本文件說明如何透過 Enzyme Protocol 的 `FundDeployer` 合約建立一個新的基金，並在建立的同時，原子性地為其設定 **1% 的申購手續費**和**申購白名單策略**。

整個流程的核心是**由內而外**地建構一個層層嵌套的設定參數 `_comptrollerConfig`，最後將其傳入 `createNewFund` 函式中一次性完成所有部署和設定。

### 核心組件

1.  **`FundDeployer`**: 基金工廠合約，是建立所有新基金的統一入口。
2.  **`ComptrollerLib`**: 每個基金的「大腦」，負責權限控制和所有操作的調度。`createNewFund` 中的設定參數最終會成為 `ComptrollerLib` 的初始狀態。
3.  **`FeeManager`**: 作為 `ComptrollerLib` 的一個標準擴展，專門管理所有費用相關的邏輯。
4.  **`PolicyManager`**: 同樣是 `ComptrollerLib` 的標準擴展，負責執行所有基金策略，如白名單、交易對限制等。
5.  **`EntranceRateDirectFee.sol`**: 一個具體的費用合約，功能是在申購時按固定比例收取費用。
6.  **`AllowedDepositRecipientsPolicy.sol`**: 一個具體的策略合約，用於限制只有白名單上的地址才能申購基金份額。
7.  **`AddressListRegistry.sol`**: 一個全域註冊表合約，用於給各類策略創建和管理可重複使用的地址列表。

### 交互流程：構建 `_comptrollerConfig`

建立基金的過程，就是構建 `IComptroller.ConfigInput` 結構體的過程。我們需要從最內層的費用和策略設定開始，逐步向外封裝。

#### 第 1 步 (前置作業): 建立白名單列表

在建立基金**之前**，您需要先呼叫 `AddressListRegistry` 合約的 `createList` 函式來建立一個地址列表，並取得 `listId`。這個 `listId` 後續將被策略合約使用。

**示例代碼:**
```solidity
// 假設 addressListRegistry 是已部署的合約實例
address[] memory whitelistAddresses = new address[](2);
whitelistAddresses[0] = 0xADDRESS_ONE;
whitelistAddresses[1] = 0xADDRESS_TWO;

// 呼叫 createList 會建立列表並返回其 ID
uint256 listId = addressListRegistry.createList(address(this), IAddressListRegistry.UpdateType.None, whitelistAddresses);
```

#### 第 2 步：準備費用和策略的設定數據 (最內層)

首先，我們需要為 `EntranceRateDirectFee` 和 `AllowedDepositRecipientsPolicy` 這兩個具體合約準備它們各自的初始化設定數據 (`bytes`)。

-   **`EntranceRateDirectFee` 的設定**:
    -   **格式**: `abi.encode(uint256 rate, address recipient)`
    -   `rate`: 費率。`100` 代表 1% (100 / 10000)。
    -   `recipient`: 接收費用的地址。
    ```solidity
    // 假設 feeRecipient 是您指定的收款地址
    bytes memory entranceFeeSettings = abi.encode(100, feeRecipient);
    ```

-   **`AllowedDepositRecipientsPolicy` 的設定**:
    -   **格式**: `abi.encode(uint256[] existingListIds, bytes[] newListsData)`
    -   `existingListIds`: 一個包含**已存在**列表 ID 的陣列。我們使用**第 1 步**中取得的 `listId`。
    -   `newListsData`: 如果想在建立基金的同時創建新列表，可在此傳入數據，此處為空。
    ```solidity
    uint256[] memory existingListIds = new uint256[](1);
    existingListIds[0] = listId; // 使用上一步取得的 listId
    bytes[] memory newListsData = new bytes[](0);

    bytes memory policySettingsData = abi.encode(existingListIds, newListsData);
    ```

#### 第 3 步：準備 FeeManager 和 PolicyManager 的設定數據 (中間層)

接下來，將上一步生成的具體設定數據，包裝成 `FeeManager` 和 `PolicyManager` 需要的格式。

-   **`FeeManager` 的設定 (`feeManagerConfigData`)**:
    -   **格式**: `abi.encode(address[] feeAddresses, bytes[] feeSettings)`
    -   `feeAddresses`: 要啟用的費用合約地址陣列。
    -   `feeSettings`: 與費用合約地址一一對應的設定數據陣列。
    ```solidity
    address[] memory fees = new address[](1);
    fees[0] = entranceRateDirectFeeAddress; // Deployed EntranceRateDirectFee 合約地址

    bytes[] memory settings = new bytes[](1);
    settings[0] = entranceFeeSettings; // 使用第 2 步的數據

    bytes memory feeManagerConfigData = abi.encode(fees, settings);
    ```

-   **`PolicyManager` 的設定 (`policyManagerConfigData`)**:
    -   **格式**: `abi.encode(address[] policyAddresses, bytes[] policySettings)`
    -   `policyAddresses`: 要啟用的策略合約地址陣列。
    -   `policySettings`: 與策略合約地址一一對應的設定數據陣列。
    ```solidity
    address[] memory policies = new address[](1);
    policies[0] = allowedDepositRecipientsPolicyAddress; // 策略合約的地址

    bytes[] memory settings = new bytes[](1);
    settings[0] = policySettingsData; // 使用第 2 步的數據

    bytes memory policyManagerConfigData = abi.encode(policies, settings);
    ```

#### 第 4 步：準備 `createNewFund` 的完整參數 (最外層)

最後，我們將 `feeManagerConfigData` 和 `policyManagerConfigData` 填入最終的 `IComptroller.ConfigInput` 結構體中。

```solidity
IComptroller.ConfigInput memory comptrollerConfig = IComptroller.ConfigInput({
    denominationAsset: 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2, // WETH
    sharesActionTimelock: 0,
    feeManagerConfigData: feeManagerConfigData,         // <--- 傳入第 3 步的費用設定
    policyManagerConfigData: policyManagerConfigData,    // <--- 傳入第 3 步的策略設定
    extensionsConfig: new IComptroller.ExtensionConfigInput[](0)
});

// 呼叫 `createNewFund` 來建立基金
(address comptrollerProxy, address vaultProxy) = fundDeployer.createNewFund(
    fundOwner,
    "My Full Config Fund",
    "MFCF",
    comptrollerConfig
);
```

### Ethers.js 交互範例

以下是如何使用 Ethers.js 來構建與上述流程完全相同的交易。

```javascript
const { ethers } = require('ethers');

// --- ABI 片段 (與 Web3.js 相同) ---
const fundDeployerAbi = [{
    "name": "createNewFund",
    "type": "function",
    "inputs": [
        { "type": "address", "name": "_fundOwner" },
        { "type": "string", "name": "_fundName" },
        { "type": "string", "name": "_fundSymbol" },
        {
            "type": "tuple", "name": "_comptrollerConfig",
            "components": [
                { "type": "address", "name": "denominationAsset" },
                { "type": "uint256", "name": "sharesActionTimelock" },
                { "type": "bytes", "name": "feeManagerConfigData" },
                { "type": "bytes", "name": "policyManagerConfigData" },
                { "type": "tuple[]", "name": "extensionsConfig", "components": [] }
            ]
        }
    ]
}];

// --- 參數設定 ---
const provider = new ethers.providers.JsonRpcProvider("https://mainnet.infura.io/v3/YOUR_PROJECT_ID");
// 在實際應用中，您需要一個簽名者來發送交易
// const signer = new ethers.Wallet("YOUR_PRIVATE_KEY", provider);
const signerAddress = "0x..."; // 您的地址

// 合約地址 (已替換為您的實際地址)
const fundDeployerAddress = "0x9D2C19a267caDA33da70d74aaBF9d2f75D3CdC14";
const entranceRateDirectFeeAddress = "0xA7259E45c7Be47a5bED94EDc252FADB09769a326";
const allowedDepositRecipientsPolicyAddress = "0x0eD7E38C4535989e392843884326925B4469EB5A";
const wethAddress = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";

// 基金和費用參數
const feeRecipient = "0x..."; // 費用收款地址
const listId = 123; // 假設這是您在第 1 步中預先建立的白名單 ID

// --- 第 2 步：準備費用和策略的設定數據 (最內層) ---
const defaultAbiCoder = ethers.utils.defaultAbiCoder;

const entranceFeeSettings = defaultAbiCoder.encode(
    ['uint256', 'address'],
    [100, feeRecipient] // 1% 費率
);

const policySettingsData = defaultAbiCoder.encode(
    ['uint256[]', 'bytes[]'],
    [[listId], []]
);

console.log("Entrance Fee Settings:", entranceFeeSettings);
console.log("Policy Settings:", policySettingsData);

// --- 第 3 步：準備 FeeManager 和 PolicyManager 的設定數據 (中間層) ---
const feeManagerConfigData = defaultAbiCoder.encode(
    ['address[]', 'bytes[]'],
    [[entranceRateDirectFeeAddress], [entranceFeeSettings]]
);

const policyManagerConfigData = defaultAbiCoder.encode(
    ['address[]', 'bytes[]'],
    [[allowedDepositRecipientsPolicyAddress], [policySettingsData]]
);

console.log("FeeManager Config Data:", feeManagerConfigData);
console.log("PolicyManager Config Data:", policyManagerConfigData);

// --- 第 4 步：準備 createNewFund 的完整參數 (最外層) ---
const comptrollerConfig = {
    denominationAsset: wethAddress,
    sharesActionTimelock: 0,
    feeManagerConfigData: feeManagerConfigData,
    policyManagerConfigData: policyManagerConfigData,
    extensionsConfig: []
};

const fundDeployer = new ethers.Contract(fundDeployerAddress, fundDeployerAbi, provider);

// 使用合約介面來編碼函數調用，更安全且不易出錯
const finalCalldata = fundDeployer.interface.encodeFunctionData("createNewFund", [
    signerAddress, // _fundOwner
    "My Full Config Fund", // _fundName
    "MFCF", // _fundSymbol
    comptrollerConfig
]);

console.log("Final Calldata for createNewFund:", finalCalldata);

// --- 第 5 步：發送交易 ---
async function sendTransaction() {
    // 確保您有一個已連接的簽名者 (signer)
    // const fundDeployerWithSigner = fundDeployer.connect(signer);
    
    const txObject = {
        to: fundDeployerAddress,
        data: finalCalldata,
        gasLimit: 2000000, // 預估 Gas Limit，應根據實際情況調整
    };

    console.log("Transaction Object:", txObject);
    
    // 使用 signer 發送交易
    // const tx = await signer.sendTransaction(txObject);
    // console.log("Transaction Hash:", tx.hash);
    // const receipt = await tx.wait();
    // console.log("Transaction receipt:", receipt);
}

// sendTransaction();
```

### 總結與設定結構圖示

整個 `_comptrollerConfig` 參數的數據結構可以總結如下：

```
_comptrollerConfig: (
    denominationAsset: WETH地址,
    sharesActionTimelock: 0,
    feeManagerConfigData: (
        // --- FeeManager 的設定 ---
        feeAddresses: [EntranceRateDirectFee地址],
        feeSettings: [
            // --- EntranceRateDirectFee 的設定 ---
            (rate: 100, recipient: 收款地址)
        ]
    ),
    policyManagerConfigData: (
        // --- PolicyManager 的設定 ---
        policyAddresses: [AllowedDepositRecipientsPolicy地址],
        policySettings: [
            // --- AllowedDepositRecipientsPolicy 的設定 ---
            (existingListIds: [listId], newListsData: [])
        ]
    ),
    extensionsConfig: []
)
```

### 設計理念

-   **原子性與不可變性**: 在單一交易中完成基金的創建和核心規則的設定。費用和策略等關鍵參數在部署時即被鎖定，增強了基金的透明度和安全性，防止了未來未經授權的修改。
-   **模組化與可擴展性**: `FeeManager` 和 `PolicyManager` 接受的是通用的位元組碼 (`bytes`) 作為設定。這種設計使得協議未來可以支持任意複雜的新費用或策略模組，而無需修改核心的 `FundDeployer` 合約，保持了良好的可擴展性。
-   **Gas 效率**: 將所有初始化設定合併到一筆交易中，相比於在基金創建後再單獨執行多筆交易來設定費用和策略，極大地節省了 Gas 成本。
