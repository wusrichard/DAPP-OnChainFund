# 基金申購流程 (buyShares)

本文件說明如何透過與基金的 `ComptrollerProxy` 合約互動來申購（購買）基金份額。與需要通過 `IntegrationManager` 的複雜外部互動（如 Uniswap 交換）不同，申購是直接與 `ComptrollerLib` 核心功能互動的直接流程。

整個流程需要兩筆獨立的交易：首先是授權（`approve`）計價資產給基金的 `VaultProxy`，然後是調用 `buyShares` 執行申購。

### 核心組件

1.  **`ComptrollerProxy`**: 基金的「大腦」和操作主入口。`buyShares` 函數就在此合約上調用。
2.  **`VaultProxy`**: 基金的「金庫」，實際持有所有資產。在申購前，用戶必須授權此合約地址可以從自己錢包轉出計價資產。
3.  **`計價資產 (Denomination Asset)`**: 用於投資的 ERC20 代幣合約（例如 WETH, USDC）。用戶需在此合約上執行 `approve` 操作。

### 交互流程

申購流程分為兩個主要步驟，需要發送兩筆獨立的鏈上交易。

#### 第 1 步：授權資產 (Approve)

在基金可以轉移您的投資款之前，您必須先授權。

- **目標合約**: 計價資產的 ERC20 合約 (例如 WETH 地址)。
- **目標 Function**: `approve(address spender, uint256 amount)`
- **參數**:
  - `spender`: `VaultProxy` 的合約地址。此地址需要通過調用 `ComptrollerProxy` 的 `getVaultProxy()` 來獲取。
  - `amount`: 您希望授權的最高投資金額。

#### 第 2 步：申購份額 (Buy Shares)

完成授權後，即可調用 `ComptrollerProxy` 的 `buyShares` 函數來完成申購。

- **目標合約**: `ComptrollerProxy`
- **目標 Function**: `buyShares(uint256 _investmentAmount, uint256 _minSharesQuantity)`
- **參數**:
  - `_investmentAmount`: 您實際希望投資的金額，此金額不能超過您在第 1 步中授權的數量。
  - `_minSharesQuantity`: 您願意接受的最低份額數量，用於滑點保護。如果預計收到的份額低於此值，交易將失敗。

### Ethers.js 交互範例

以下是如何使用 Ethers.js 來完成完整的申購流程。

```javascript
// --- 準備 ABI (可以使用更簡潔的 Human-Readable ABI) ---
const comptrollerAbi = [
    "function getVaultProxy() external view returns (address)",
    "function buyShares(uint256 _investmentAmount, uint256 _minSharesQuantity) external returns (uint256)"
];

const erc20Abi = [
    "function approve(address spender, uint256 amount) external returns (bool)",
    "function allowance(address owner, address spender) external view returns (uint256)"
];

// --- 參數設定 ---
const { ethers } = require("ethers");

// 連接到以太坊網絡 (請替換為您的 RPC URL)
const provider = new ethers.providers.JsonRpcProvider("https://mainnet.infura.io/v3/YOUR_PROJECT_ID");

// 您的錢包 (請確保有足夠的計價資產和 ETH支付 Gas)
const privateKey = "YOUR_PRIVATE_KEY";
const wallet = new ethers.Wallet(privateKey, provider);

// 合約地址 (請替換為您的實際地址)
const comptrollerProxyAddress = "0x..."; // 基金的 ComptrollerProxy 地址
const investmentAssetAddress = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"; // 投資資產地址 (此處為 WETH)

// 交易參數
const investmentAmount = ethers.utils.parseEther("1.0"); // 投資 1.0 WETH
const minSharesQuantity = ethers.utils.parseUnits("0.95", 18); // 假設滑點保護為 0.95 份額

// --- 創建合約實例 ---
const comptroller = new ethers.Contract(comptrollerProxyAddress, comptrollerAbi, wallet);
const investmentAsset = new ethers.Contract(investmentAssetAddress, erc20Abi, wallet);

// --- 執行申購流程 ---
async function subscribeToFund() {
    try {
        // --- 第 1 步：授權 ---
        console.log("Fetching VaultProxy address...");
        const vaultProxyAddress = await comptroller.getVaultProxy();
        console.log(`VaultProxy address: ${vaultProxyAddress}`);

        console.log(`Checking allowance for ${vaultProxyAddress}...`);
        const currentAllowance = await investmentAsset.allowance(wallet.address, vaultProxyAddress);
        
        if (currentAllowance.lt(investmentAmount)) {
            console.log("Allowance is insufficient, sending approve transaction...");
            const approveTx = await investmentAsset.approve(vaultProxyAddress, investmentAmount);
            console.log(`Approve transaction sent: ${approveTx.hash}`);
            await approveTx.wait(); // 等待交易被挖掘
            console.log("Approve transaction confirmed.");
        } else {
            console.log("Sufficient allowance already granted.");
        }

        // --- 第 2 步：申購 ---
        console.log("Sending buyShares transaction...");
        const buySharesTx = await comptroller.buyShares(investmentAmount, minSharesQuantity);
        console.log(`buyShares transaction sent: ${buySharesTx.hash}`);
        
        const receipt = await buySharesTx.wait();
        console.log("buyShares transaction confirmed.");
        
        // 在實際應用中，您可以解析 receipt.logs 來獲取 `SharesBought` 事件中的份額數量
        console.log("Subscription successful! Transaction was mined in block:", receipt.blockNumber);

    } catch (error) {
        console.error("Subscription failed:", error);
    }
}

subscribeToFund();
```

### 總結與調用鏈圖示

整個申購流程的調用鏈相對直接：

1.  **交易一 (Approve)**
    ```
    用戶錢包 -> ERC20.approve(vaultProxyAddress, amount)
    ```
2.  **交易二 (Buy Shares)**
    ```
    用戶錢包 -> ComptrollerProxy.buyShares(amount, minShares)
                  |
                  └─ (內部調用) -> VaultProxy (處理資產轉移和份額鑄造)
    ```

### 代理申購 (On Behalf Of)

`ComptrollerLib` 同時提供 `buySharesOnBehalf` 函式，允許一個帳戶為另一個帳戶購買份額。

**函式簽名:**
```solidity
function buySharesOnBehalf(
    address _buyer,
    uint256 _investmentAmount,
    uint256 _minSharesQuantity
) external returns (uint256 sharesReceived_);
```
- **`_buyer` (`address`)**: 份額的最終接收者地址。
- **調用者 (`msg.sender`)**: 必須是已獲得 `_investmentAmount` 資產授權的地址。在這種情況下，`approve` 的是 `msg.sender` 而不是 `_buyer`。