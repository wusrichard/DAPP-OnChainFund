# 基金贖回流程 (Redemption)

本文件說明投資者如何將其持有的基金份額（Shares）贖回，以換取基金中的底層資產。贖回是直接與 `ComptrollerLib` 核心功能互動的流程，通過在 `VaultProxy` 上發起一筆交易來完成。

與需要事先 `approve` 的申購流程不同，贖回是銷毀用戶自己的份額，因此無需授權，整個過程在單一交易中原子性地完成。

### 核心組件

1.  **`ComptrollerLib`**: 基金的「大腦」，贖回的核心邏輯在此實現。它計算應支付的資產數量並執行銷毀份額的操作。
2.  **`VaultProxy`**: 基金的「金庫」與交易的統一入口。用戶通過調用此合約的贖回函數來發起請求，`VaultProxy` 會代理（delegate）調用至 `ComptrollerLib` 的邏輯並支付資產。
3.  **用戶錢包**: 持有基金份額，並作為贖回交易的發起者和資產的接收者。

### 交互流程

贖回是一個單一的交易步驟，由份額持有人直接調用 `VaultProxy` 上的目標函數來觸發。

- **目標合約**: `VaultProxy`
- **目標 Function**: `redeemSharesInKind` 或 `redeemSharesForSpecificAssets`
- **核心邏輯**: 用戶調用 `VaultProxy` -> `VaultProxy` 代理執行 `ComptrollerLib` 中的贖回邏輯 -> `ComptrollerLib` 計算並指令 `VaultProxy` 將對應的資產發送給用戶 -> `VaultProxy` 銷毀用戶的基金份額。

`ComptrollerLib` 提供了兩種贖回模式，以滿足不同場景的需求。

--- 

### 方式一：按比例贖回 (Proportional Redemption)

此方式允許用戶按其持有份額佔總份額的比例，贖回基金追蹤的所有類型資產的一部分。這是最標準的退出方式。

**Ethers.js 交互範例 (`redeemSharesInKind`)**

```javascript
// --- 準備 ABI ---
const vaultProxyAbi = [
    "function redeemSharesInKind(address _recipient, uint256 _sharesQuantity, address[] _additionalAssets, address[] _assetsToSkip) external returns (address[], uint256[])"
];

// --- 參數設定 ---
const { ethers } = require("ethers");

// 連接到以太坊網絡
const provider = new ethers.providers.JsonRpcProvider("https://mainnet.infura.io/v3/YOUR_PROJECT_ID");

// 您的錢包 (必須持有該基金的份額)
const privateKey = "YOUR_PRIVATE_KEY";
const wallet = new ethers.Wallet(privateKey, provider);

// 合約地址
const vaultProxyAddress = "0x..."; // 基金的 VaultProxy 地址

// --- 創建合約實例 ---
const vaultProxy = new ethers.Contract(vaultProxyAddress, vaultProxyAbi, wallet);

// --- 執行贖回 ---
async function redeemProportionally() {
    try {
        const sharesToRedeem = ethers.utils.parseEther("10.0"); // 贖回 10 個份額
        const recipient = wallet.address; // 贖回的資產發送到自己的錢包
        const additionalAssets = []; // 通常為空
        const assetsToSkip = []; // 通常為空，除非需要跳過某些有問題的資產

        console.log(`Attempting to redeem ${ethers.utils.formatEther(sharesToRedeem)} shares...`);

        const redeemTx = await vaultProxy.redeemSharesInKind(
            recipient,
            sharesToRedeem,
            additionalAssets,
            assetsToSkip
        );

        console.log(`Redemption transaction sent: ${redeemTx.hash}`);
        const receipt = await redeemTx.wait();
        console.log("Redemption successful! Transaction was mined in block:", receipt.blockNumber);

        // 返回值 payoutAssets_ 和 payoutAmounts_ 可以在日誌中解析或通過調用返回值獲取

    } catch (error) {
        console.error("Proportional redemption failed:", error);
    }
}

redeemProportionally();
```

--- 

### 方式二：指定資產贖回 (Specific Asset Redemption)

此方式給予用戶極大的靈活性，允許用戶指定僅贖回一種或多種特定的資產。例如，用戶可以選擇只接收穩定幣（如 USDC），而放棄其他所有資產。

**Ethers.js 交互範例 (`redeemSharesForSpecificAssets`)**

```javascript
// --- 準備 ABI ---
const vaultProxyAbi = [
    "function redeemSharesForSpecificAssets(address _recipient, uint256 _sharesQuantity, address[] _payoutAssets, uint256[] _payoutAssetPercentages) external returns (uint256[])"
];

// --- 參數設定 ---
const { ethers } = require("ethers");
const provider = new ethers.providers.JsonRpcProvider("https://mainnet.infura.io/v3/YOUR_PROJECT_ID");
const privateKey = "YOUR_PRIVATE_KEY";
const wallet = new ethers.Wallet(privateKey, provider);

const vaultProxyAddress = "0x..."; // 基金的 VaultProxy 地址
const usdcAddress = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
const wethAddress = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";

// --- 創建合約實例 ---
const vaultProxy = new ethers.Contract(vaultProxyAddress, vaultProxyAbi, wallet);

// --- 執行贖回 ---
async function redeemForSpecificAssets() {
    try {
        const sharesToRedeem = ethers.utils.parseEther("10.0"); // 贖回 10 個份額
        const recipient = wallet.address;

        // 指定贖回資產和比例：70% USDC, 30% WETH
        const payoutAssets = [usdcAddress, wethAddress];
        // 7000 + 3000 = 10000 (代表 100%)
        const payoutAssetPercentages = [7000, 3000]; 

        console.log(`Attempting to redeem ${ethers.utils.formatEther(sharesToRedeem)} shares for specific assets...`);

        const redeemTx = await vaultProxy.redeemSharesForSpecificAssets(
            recipient,
            sharesToRedeem,
            payoutAssets,
            payoutAssetPercentages
        );

        console.log(`Specific redemption transaction sent: ${redeemTx.hash}`);
        const receipt = await redeemTx.wait();
        console.log("Specific redemption successful! Transaction was mined in block:", receipt.blockNumber);

    } catch (error) {
        console.error("Specific redemption failed:", error);
    }
}

redeemForSpecificAssets();
```

### 總結與調用鏈圖示

贖回的調用鏈非常直接，在單一交易中完成：

```
用戶錢包 -> VaultProxy.redeemShares* (...)
              |
              └─ (DELEGATECALL) -> ComptrollerLib (執行核心贖回邏輯)
                                  |
                                  └─ (內部指令) -> VaultProxy (轉移資產 & 銷毀份額)
```